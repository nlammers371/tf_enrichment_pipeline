function sweepTemp = run_mcmc_sampling(sweepInfo)

% make directory to store temporary files
% tempSavePath = [savePath filesep sweepInfo.simType '_tempSweepFiles' filesep];
% mkdir(tempSavePath)

% initialize parallel pools
if sweepInfo.n_chains > 5
    initializePool(sweepInfo)
end

% initialize stuff for waitbar
WB = waitbar(0,'conducting parameter sweeps...');
% D = parallel.pool.DataQueue;    
% afterEach(D, @nUpdateWaitbar);
% 
% N = sweepInfo.nIterations;
% p = 1;
    
% iterate through different param values
for chain = 1
    for sweep_step = 1:sweepInfo.n_iters_max
        % increment waitbar
        waitbar(sweep_step/sweepInfo.n_iters_max,WB);
        
        % first, we need to generate new values to test
        if sweep_step==1
            [sweepInfo, prop_params] = initialGuessMCMC(sweepInfo);
        else
            sweepInfo = proposeMoveMCMC(sweepInfo);
        end
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%% Check goodness of fit
        sweepTemp = struct;
        sweepTemp.param_val_vec = prop_params;
        
        % conduct RA simulations
        sweepTemp = io_prediction_wrapper_ra(sweepInfo,sweepTemp(sweep_step));
        
        % conduct WT simulations
        sweepTemp = io_prediction_wrapper_wt(sweepInfo,sweepTemp);

        % 
        % update waitbar
        if sweep_step == 1
            simInfo.paramFits(1,:) = sweepTemp.param_val_vec;
            simInfo.paramFits(1,:) = sweepTemp.param_val_vec;
            simInfo.paramFits(1,:) = sweepTemp.param_val_vec;
            simInfo.paramFits(1,:) = sweepTemp.param_val_vec;
    end
end
% delete pool (necessary to clear from RAM)
% delete(gcp) 
 
delete(WB);

% sweepTempFull = reassembleTempResults(tempSavePath,sweepInfo.nIterations);

% helper function
% function nUpdateWaitbar(~)
%   waitbar(p/N, WB);
%   p = p + 1;
% end


end